---
title: "Introduction to ROS 2 Concepts"
description: "Learn the fundamental concepts of ROS 2 including nodes, topics, services, and actions"
sidebar_position: 1
---

# Introduction to ROS 2 Concepts

## Learning Objectives

- Understand the core concepts of ROS 2 architecture
- Learn about nodes, topics, services, and actions
- Grasp the differences between ROS 1 and ROS 2
- Recognize the role of DDS in ROS 2 communication

## Prerequisites

- Basic understanding of Python programming
- Familiarity with command-line interfaces

## What is ROS 2?

ROS 2 (Robot Operating System 2) is a flexible framework for writing robot software. It's a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robot platforms.

Unlike traditional operating systems, ROS 2 is not an actual operating system but rather a middleware that provides services designed for a heterogeneous computer cluster. It includes hardware abstraction, device drivers, libraries, visualizers, message-passing, package management, and more.

## Core Architecture Components

### Nodes

A node is an executable that uses ROS 2 to communicate with other nodes. Nodes are the fundamental building blocks of a ROS 2 system. Each node runs a specific task and communicates with other nodes through topics, services, or actions.

In Python, nodes are created by subclassing the `rclpy.node.Node` class:

```python
import rclpy
from rclpy.node import Node

class MinimalNode(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        # Node initialization code goes here
```

Let's look at a more complete example of a simple publisher node:

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello World: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = MinimalPublisher()
    rclpy.spin(minimal_publisher)
    minimal_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

This example demonstrates:
- Node initialization with a name
- Creating a publisher for String messages
- Setting up a timer to publish messages at regular intervals
- A callback function that executes on each timer tick
- Proper cleanup when the node shuts down

### Topics and Message Passing

Topics enable asynchronous communication between nodes through a publish/subscribe model. Publishers send messages to topics, and subscribers receive messages from topics. This decouples nodes from each other, allowing for flexible system design.

Key characteristics of topics:
- Unidirectional data flow (publisher to subscriber)
- Asynchronous communication
- Multiple publishers and subscribers can connect to the same topic
- Data is distributed in a many-to-many fashion

### Services

Services provide synchronous request/response communication between nodes. A client sends a request to a service server, which processes the request and returns a response.

Service communication is appropriate when:
- You need guaranteed delivery of a request and response
- The communication follows a clear request-response pattern
- You want synchronous behavior

### Actions

Actions are a more advanced form of communication that supports long-running tasks with feedback and goal management. Actions include:
- Goal: Request to start a long-running task
- Feedback: Periodic updates during task execution
- Result: Final outcome when the task completes

Actions are ideal for tasks like navigation, where you need to send a goal (navigate to location X), receive feedback (current progress), and get a result (navigation completed successfully).

## DDS (Data Distribution Service)

ROS 2 uses DDS as its underlying communication middleware. DDS (Data Distribution Service) is a standard for distributed systems that provides discovery, serialization, and transport of data between applications.

Key benefits of DDS in ROS 2:
- Language and platform independence
- Built-in Quality of Service (QoS) policies
- Robust discovery mechanisms
- Support for various transport protocols

## Quality of Service (QoS)

QoS policies in ROS 2 allow you to specify requirements for communication reliability, durability, liveliness, and other aspects. This is particularly important in robotics applications where reliability requirements can vary based on the use case.

Common QoS profiles include:
- `qos_profile_sensor_data`: For high-frequency data like sensor readings
- `qos_profile_services_default`: For service calls
- `qos_profile_parameters`: For parameter updates

## Key Takeaways

- ROS 2 is a middleware framework for robot software development
- Nodes are the basic execution units that communicate through topics, services, and actions
- DDS provides the underlying communication infrastructure
- QoS policies allow fine-tuning of communication behavior
- Understanding these concepts is fundamental to working with ROS 2 systems

## References and Further Reading

For more detailed information about the concepts covered in this lesson, refer to the official ROS 2 documentation:

- [ROS 2 Documentation](https://docs.ros.org/en/humble/) - Comprehensive guide to ROS 2 Humble Hawksbill
- [Concepts: Nodes, Topics, Services, Actions](https://docs.ros.org/en/humble/Concepts.html) - Detailed explanation of core concepts
- [DDS in ROS 2](https://docs.ros.org/en/humble/Concepts/About-Different-Middleware-Vendors.html) - Information about DDS and its role in ROS 2
- [Quality of Service](https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html) - Complete guide to QoS policies and settings

## Next Steps

In the next lesson, we'll set up your ROS 2 environment and learn how to create your first ROS 2 node.
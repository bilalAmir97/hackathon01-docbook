---
title: Actions - Goal-Based Communication
description: "Explore ROS 2 actions for long-running operations with feedback and status updates in robotic systems."
sidebar_position: 2
---

# Actions - Goal-Based Communication

## Introduction to ROS 2 Actions

While services are excellent for simple request-response operations, they fall short when dealing with long-running tasks that require continuous feedback and the ability to cancel operations. This is where ROS 2 actions come into play.

Actions are designed for tasks that:
- Take a significant amount of time to complete
- Need to provide periodic feedback during execution
- Can be preempted or canceled
- Have a clear goal, progress tracking, and result

## Action Architecture

ROS 2 actions follow a client-server pattern with three key message types:

- **Goal**: Defines what the action should accomplish
- **Feedback**: Provides periodic updates on progress
- **Result**: Contains the final outcome when the action completes

The action interface is defined using `.action` files with three sections:
```
# Goal definition
---
# Result definition
---
# Feedback definition
```

## Creating an Action Server

Let's create an action server example. In practice, you would use a specific action interface from a ROS 2 package like `nav2_msgs` for navigation or `control_msgs` for joint control. For this example, we'll demonstrate the structure using a simplified approach:

```python
#!/usr/bin/env python3
import time
import rclpy
from rclpy.action import ActionServer
from rclpy.node import Node
from rclpy.executors import MultiThreadedExecutor

# For this example, we'll use a built-in action interface
# In practice, you'd use specific action types like:
# from nav2_msgs.action import NavigateToPose
# from control_msgs.action import FollowJointTrajectory
# from moveit_msgs.action import MoveGroup

# For demonstration, we'll use a simple example based on the Fibonacci action pattern
from example_interfaces.action import Fibonacci

class FibonacciActionServer(Node):
    def __init__(self):
        super().__init__('fibonacci_action_server')

        # In a real implementation, you would use a specific action type
        # self._action_server = ActionServer(
        #     self,
        #     NavigateToPose,  # Your action type
        #     'navigate_to_pose',  # Action name
        #     self.execute_callback  # Execution callback
        # )

        self.get_logger().info('Fibonacci action server initialized (example)')

    def execute_callback(self, goal_handle):
        """Execute the action goal"""
        self.get_logger().info('Executing goal...')

        # In a real implementation, you would:
        # 1. Get the goal parameters from goal_handle.request
        # 2. Execute the requested action
        # 3. Send feedback periodically
        # 4. Return the final result

        # Example: Generate a Fibonacci sequence
        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]

        # Simulate work with feedback
        for i in range(1, goal_handle.request.order):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled')
                result = Fibonacci.Result()
                result.sequence = feedback_msg.sequence
                return result

            feedback_msg.sequence.append(
                feedback_msg.sequence[i] + feedback_msg.sequence[i-1]
            )

            goal_handle.publish_feedback(feedback_msg)
            self.get_logger().info(f'Feedback: {feedback_msg.sequence}')

            time.sleep(0.5)  # Simulate work

        goal_handle.succeed()
        result = Fibonacci.Result()
        result.sequence = feedback_msg.sequence

        self.get_logger().info(f'Result: {result.sequence}')
        return result


def main(args=None):
    rclpy.init(args=args)
    node = FibonacciActionServer()

    try:
        # In a real implementation, the action server would handle execution
        node.get_logger().info('Action server running (example). See companion client.')
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Creating an Action Client

Now let's create a client that sends goals to our action server:

```python
#!/usr/bin/env python3
import time
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from example_interfaces.action import Fibonacci

class FibonacciActionClient(Node):
    def __init__(self):
        super().__init__('fibonacci_action_client')

        # In a real implementation, you would connect to a specific action server
        # self._action_client = ActionClient(
        #     self,
        #     NavigateToPose,  # Your action type
        #     'navigate_to_pose'  # Action name
        # )

        self.get_logger().info('Fibonacci action client initialized (example)')

    def send_goal(self, order=5):
        """Send a goal to the action server"""
        self.get_logger().info('Waiting for action server...')

        # In a real implementation:
        # goal_msg = NavigateToPose.Goal()
        # goal_msg.pose = your_target_pose
        #
        # self._action_client.wait_for_server()
        # send_goal_future = self._action_client.send_goal_async(
        #     goal_msg,
        #     feedback_callback=self.feedback_callback
        # )
        #
        # send_goal_future.add_done_callback(self.goal_response_callback)

        self.get_logger().info(f'Goal sent (order: {order}) - would wait for result in real implementation')

    def feedback_callback(self, feedback_msg):
        """Handle feedback during action execution"""
        self.get_logger().info(f'Received feedback: {feedback_msg.partial_sequence}')

    def goal_response_callback(self, future):
        """Handle goal acceptance/rejection"""
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected')
            return

        self.get_logger().info('Goal accepted')
        get_result_future = goal_handle.get_result_async()
        get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        """Handle final result"""
        result = future.result().result
        self.get_logger().info(f'Result received: {result.sequence}')


def main(args=None):
    rclpy.init(args=args)
    client = FibonacciActionClient()

    try:
        client.send_goal(order=10)

        # In a real implementation, you would spin to receive feedback and results
        timeout = time.time() + 15.0  # 15 second timeout
        while rclpy.ok() and time.time() < timeout:
            rclpy.spin_once(client, timeout_sec=0.1)

    except KeyboardInterrupt:
        pass
    finally:
        client.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Custom Action Definition

For more specific use cases, you might need to define custom actions. Here's an example of a custom action for robot arm manipulation:

```
# Goal: Specify target joint positions
float64[] joint_positions
float64 timeout
---
# Result: Success status and final positions
bool success
float64[] final_positions
string message
---
# Feedback: Current progress and joint states
float64[] current_positions
float64[] target_positions
float64 progress_percentage
string status
```

## Action Best Practices

1. **Use actions for long-running operations**: Actions are perfect for tasks like navigation, manipulation, or calibration that take time.

2. **Provide meaningful feedback**: Regular feedback helps clients understand progress and make informed decisions.

3. **Handle cancellation gracefully**: Always check for cancellation requests and clean up resources appropriately.

4. **Set appropriate timeouts**: Long-running actions should have reasonable timeouts to prevent indefinite waiting.

5. **Design clear interfaces**: Make goal, feedback, and result messages intuitive and comprehensive.

## When to Use Actions vs. Services vs. Topics

Choose actions when:
- The operation takes a significant amount of time
- You need to provide feedback during execution
- The operation might need to be canceled
- You need to track progress toward a goal

Choose services when:
- You need a simple request-response interaction
- The operation is relatively quick
- You don't need intermediate feedback

Choose topics when:
- You need continuous data streaming
- Multiple subscribers need the same information
- The communication is asynchronous

## Summary

Actions provide a sophisticated communication pattern for complex robotic operations that require feedback, cancellation, and progress tracking. By mastering actions, you can build more responsive and robust robotic systems that handle long-running tasks effectively.